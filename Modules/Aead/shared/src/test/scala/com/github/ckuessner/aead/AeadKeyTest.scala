package com.github.ckuessner.aead

import com.github.ckuessner.aead.{AeadKey, ByteArray}

import scala.concurrent.ExecutionContext
import scala.util.{Failure, Success}

class AeadKeyTest extends munit.FunSuite {

  given executionContext: ExecutionContext = TestExecutionContext.executionContext

  test("AeadHelper.ready should work") {
    AeadHelper.ready().map(_ => ())(using executionContext)
  }

  test("fromRawKey should work with base64 encoded keys generated by Tink") {
    val keys = Array(
      "Kd3Gx1XkDGtJk/I5xAbqQ0VtlL8YyYo+ENmfV7IvDhs=",
      "gJlYyb4ZtjIdhdhBNrVDh4lqFW+qJv4ciOFQOfNlaZY="
    )

    keys.foreach { base64Key =>
      val key        = AeadKey.fromRawKey(base64Key)
      val ciphertext = key.aeadPrimitive.encrypt("Test", "123").get
      assertEquals(Success("Test"), key.aeadPrimitive.decrypt(ciphertext, "123"))
    }

  }

  test("should work with base64 encoded keys generated by Libsodium.js") {
    val keys = Array(
      "A4HzAlyQdmZJa+qKnuynLDL7XJ0hJUn/sf1sFQNZkt8=",
      "qVlUD8gkSojdvCW0pGYIP8zvYKiaMfu7UDVCyoj/Qqo="
    )

    keys.foreach { base64Key =>
      val key        = AeadKey.fromRawKey(base64Key)
      val ciphertext = key.aeadPrimitive.encrypt("Test", "123").get
      assertEquals(Success("Test"), key.aeadPrimitive.decrypt(ciphertext, "123"))
    }

  }

  test("should be able to load raw key") {
    val key                  = AeadKey.generateKey
    val ciphertext           = key.aeadPrimitive.encrypt("Hello", "World").get
    val rawKey               = key.rawKeyBytes
    val importedKey: AeadKey = AeadKey.fromRawKey(rawKey)
    assertEquals(Success("Hello"), importedKey.aeadPrimitive.decrypt(ciphertext, "World"))
  }

  test("generateKey should provide keys that can encrypt and decrypt") {
    val key: AeadKey = AeadKey.generateKey
    val aead         = key.aeadPrimitive
    aead.encrypt("Hello World!", "Test123") match {
      case Failure(exception) => fail("Could not encrypt with generated key", exception)
      case Success(ciphertext) =>
        aead.decrypt(ciphertext, "Test123") match {
          case Failure(exception) => fail("Could not decrypt with generated key", exception)
          case Success(plaintext) => assertEquals("Hello World!", plaintext)
        }
    }
  }

}
